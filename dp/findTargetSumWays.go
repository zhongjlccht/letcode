package dp

import "math"

//给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
//
//返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
//
//示例：
//
//输入：nums: [1, 1, 1, 1, 1], S: 3
//输出：5
//解释：
//
//-1+1+1+1+1 = 3
//+1-1+1+1+1 = 3
//+1+1-1+1+1 = 3
//+1+1+1-1+1 = 3
//+1+1+1+1-1 = 3
//一共有5种方法让最终目标和为3。
//
//提示：
//
//数组非空，且长度不会超过 20 。
//初始的数组的和不会超过 1000 。
//保证返回的最终结果能被 32 位整数存下

//如何转化为01背包问题呢。
//
//假设加法的总和为x，那么减法对应的总和就是sum - x。
//
//所以我们要求的是 x - (sum - x) = target
//
//x = (target + sum) / 2
//
//此时问题就转化为，装满容量为x的背包，有几种方法。
//
//这里的x，就是bagSize，也就是我们后面要求的背包容量。

//有哪些来源可以推出dp[j]呢？
//
//只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。
//
//例如：dp[j]，j 为5，
//
//已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
//已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
//已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
//已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
//已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包
//那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。
//
//所以求组合类问题的公式，都是类似这种：
//dp[j] += dp[j - nums[i]]

// 目标和
func findTargetSumWays(nums []int, target int) int {
	sum := 0
	for _, v := range nums {
		sum += v
	}
	if abs(target) > sum { // 目标值大于全部总和，无解，哪怕全部取 + 符合，也凑不齐
		return 0
	}
	if (sum+target)%2 == 1 { //说明计算 (sum + target) / 2 会出现向下取整，无解
		return 0
	}
	// 计算背包大小
	bag := (sum + target) / 2
	// 定义dp数组
	dp := make([]int, bag+1)
	// 初始化
	dp[0] = 1
	// 遍历顺序
	for i := 0; i < len(nums); i++ {
		for j := bag; j >= nums[i]; j-- { // 倒序遍历背包
			//推导公式
			dp[j] += dp[j-nums[i]]
			//fmt.Println(dp)
		}
	}
	return dp[bag]
}

func abs(x int) int {
	return int(math.Abs(float64(x)))
}
