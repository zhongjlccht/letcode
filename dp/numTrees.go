package dp

//给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
// 二叉树，左侧分支数值比顶点小，右侧分支数值比顶点大
// 示例：输入3，
// 输出 5
// 分析，1为顶点有2种树，2为顶点有1种树，3为顶点有2种树

//dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
//
//元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
//
//元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
//
//元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
//
//有2个元素的搜索树数量就是dp[2]。
//
//有1个元素的搜索树数量就是dp[1]。
//
//有0个元素的搜索树数量就是dp[0]。
//
//所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
// dp[i] += dp[j-1] * dp[i-j]

// 不同的二叉搜索树
func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0] = 1 //只有一层空节点的树也是1种树
	for i := 1; i <= n; i++ {
		for j := 1; j <= i; j++ {
			dp[i] += dp[j-1] * dp[i-j]
		}
	}
	return dp[n]
}
